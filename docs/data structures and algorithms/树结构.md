
# 重点

二叉树
赫夫曼树
二叉排序树

# 树结构

线性结构  取值简单，插入数据困难。
链表  插入简单，取值需要遍历。

## 概念

根节点
双亲节点
子节点
路径
节点的度。子节点的个数。
节点的权。节点上赋值的值。
叶子节点。没有子节点的节点。
子树
层
树的高度。最大层数。
森林。多棵树。


空树。一个节点也没有。
左斜树。都只有左节点。
右斜树。都只有右节点。



# 二叉树

任何一个节点的子节点数量不超过2.
二叉树的子节点分左节点和右节点。两个节点不能颠倒。

## 满二叉树

所有叶子节点都在最后一层，而且节点的总数为2^n-1。n是树的高度。

## 完全二叉树

所有叶子节点都在最后一层或倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子
节点连续。



# 二叉树的存储结构

## 链式存储的二叉树

创建二叉树
添加节点

例如：树
   1
 2   3
4 5 6 7

二叉树遍历： 针对自己这个节点而言。
1. 前序遍历， 自己，左子节点，右子节点。并递归下去。  1   2 4 5  3 6 7
2. 中序遍历， 左子节点，自己，右子节点。递归。 4 2 5   1   6 3 7
3. 后序遍历。 左子节点，右子节点，自己。递归。 4 5 2  6 7 3   1


删除节点

查找节点

## 顺序存储的二叉树

逻辑结构，二叉树。
存储结构，顺序存储。

顺序存储的二叉树，通常只考虑完全二叉树。
第n个元素的左子节点是  2*n+1;
第n个元素的右子节点是  2*n+2;
第n个元素的父节点是  （n-1）/2;



## 堆排序

升序排序使用大顶堆。
降序排序使用小顶堆。


# 线索二叉树 

前序线索二叉树
中序线索二叉树
后序线索二叉树

线索化二叉树时，一个节点的前一个节点，叫做前驱节点。
线索化二叉树时，一个节点的后一个节点，叫做后驱节点。


# 赫夫曼树 （重点）
最优二叉树。是n个带权叶子节点构成的所有二叉树中，
带权路径长度最小的二叉树。

叶节点的带权路径。

树的带权路径长度WPL。树中所有叶子节点的带权路径长度之和 。

赫夫曼树：最优二叉树。
权值越大的节点离根节点越近的二叉树才是最优二叉树。 WPL最小。

## 创建赫夫曼树

1. 排序，
2. 取出权值最小的两个二叉树，
3. 组成一个新的二叉树，前面取出的两个二叉树是新二叉树的两个子树
4. 根节点的权值是前面取出来的两个二叉树的根节点的权值之和。
重复 1. 2. 3. 4. 
直到创建赫夫曼树。


## 赫夫曼编码

1. 定长编码。字符转成ASCII码。
2. 非定长编码。计数，按照出现次数多的编码长度小，出现少的编码长度大。
字符编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码。
3. 赫夫曼编码。
对所有字符进行计数，计数大小，从小到大排序。生成赫夫曼树。每个节点左侧路径0，右侧路径1.
形成赫夫曼编码表。编码。由于路径唯一，所以是前缀编码。

步骤：
1. 统计字符数并排序。
2. 创建赫夫曼树。
3. 创建赫夫曼编码表。
4. 编码。



## 二叉排序树 重点

线性结构
顺序存储，不排序，查找困难。

顺序存储，排序。插入删除困难。

链式存储，无论是否排序。查找困难，必须从头开始遍历。

二叉排序树也叫二叉查找树，二叉搜索树：BST。
对于二叉树中的任何一个非叶子节点，要求左子节点比
当前节点值小，右子节点比当前节点值大。


## 创建二叉排序树。
## 添加，查找，遍历，删除


## AVL树（平衡二叉树）
二叉排序树的问题：
如果不平衡，类似一条斜线。这样查找困难。失去了二叉排序树的优势。

平衡二叉树是一种二叉排序树。
任何一个节点的左子树和右子树的高度差的绝对值不超过1.

## 构建平衡二叉树 单旋转

## 构建平衡二叉树 双旋转



## 多路查找树  文件系统或数据库系统中

### 计算机的存储
### 2-3树 和 2-3-4树
B 树的所有叶节点都在同一层。
### B树 和 B+树 

