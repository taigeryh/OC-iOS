# Messaging

本章描述如何将消息表达式转换为objc_msgSend函数调用，以及如何通过名称引用方法。然后解释如何利用objc_msgSend，以及如何(如果需要的话)规避动态绑定。

## The objc_msgSend Function

在Objective-C中，消息直到运行时才绑定到方法实现。编译器转换消息表达式`[receiver message]`转换为对消息传递函数objc_msgSend的调用。
该函数以接收方和消息中提到的方法名称——即方法选择器——作为其两个主要参数:`objc_msgSend(receiver, selector)`,
消息中传递的任何参数也传递给objc_msgSend:`objc_msgSend(receiver, selector, arg1, arg2, ...)`.
消息传递函数完成动态绑定所需的所有工作:
1. 它首先找到选择器引用的过程(方法实现)。由于相同的方法可以由不同的类以不同的方式实现，因此它找到的精确过程取决于接收方的类。
2. 然后调用该过程，将接收对象(指向其数据的指针)和为该方法指定的任何参数传递给它。
3. 最后，它将过程的返回值作为它自己的返回值传递。

`编译器生成对消息传递函数的调用。永远不要在编写的代码中直接调用它。`

消息传递的关键在于编译器为每个类和对象构建的结构。每个类结构都包含这两个基本元素:
1. 指向超类的指针。
2. 类分派表(A class dispatch table)。该表中的条目将方法选择器与它们识别的方法的类特定地址相关联。setOrigin::方法的选择器与(实现的过程)setOrigin::的地址相关联，显示方法的选择器与显示的地址相关联，等等。

创建新对象时，将为其分配内存，并初始化其实例变量。在对象的变量中，首先是指向其类结构的指针。这个指针称为isa，它让对象访问它的类，并通过类访问它继承的所有类。

虽然isa指针并不是严格意义上的语言的一部分，但是一个对象在Objective-C运行时系统中工作需要isa指针。在结构定义的任何字段中，对象需要与结构objc_object(在objc/ object .h中定义)“等效”。但是，您很少(如果有的话)需要创建自己的根对象，并且从NSObject或NSProxy继承的对象自动具有isa变量。

messaging framework.png

当消息被发送到对象时，消息传递函数跟随对象的isa指针指向类结构，在类结构中查找分派表中的方法选择器。如果在那里找不到选择器，objc_msgSend会跟随指向超类的指针，并试图在它的分派表中找到选择器。连续的失败会导致objc_msgSend在到达NSObject类之前一直在类层次结构中攀升。一旦找到选择器，函数调用表中输入的方法，并将接收对象的数据结构传递给该方法。

这就是在运行时选择方法实现的方式——或者，用面向对象编程的术语来说，方法是动态绑定到消息的。

为了加快消息传递过程，运行时系统在使用方法时缓存选择器和地址。每个类都有一个单独的缓存，它可以包含继承方法和类中定义的方法的选择器。在搜索分派表之前，消息传递例程首先检查接收对象的类的缓存(理论上，曾经使用过的方法可能会再次使用)。如果方法选择器在缓存中，消息传递只比函数调用稍微慢一点。一旦一个程序运行了足够长的时间来“预热”它的缓存，它发送的几乎所有消息都会找到一个缓存的方法。缓存会随着程序的运行而动态增长，以适应新的消息。

## Using Hidden Arguments

当objc_msgSend找到实现方法的过程时，它调用该过程并将消息中的所有参数传递给它。它还传递过程两个隐藏参数:
1. 接收对象。
2. 方法的选择器。

这些参数为每个方法实现提供有关调用它的消息表达式的两个部分的显式信息。它们被称为“隐藏”，因为它们没有在定义方法的源代码中声明。它们在编译代码时被插入到实现中。

虽然这些参数没有显式声明，但是源代码仍然可以引用它们(就像它可以引用接收对象的实例变量一样)。方法将接收对象引用为self，并将其自己的选择器引用为_cmd。在下面的示例中，_cmd引用 strange 方法的选择器，self引用接收 strange 消息的对象。

```
- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();
 
    if ( target == self || method == _cmd )
        return nil;
    return [target performSelector:method];
}

```

在这两个参数中，self更有用。接收对象的实例变量可用于方法定义中。


## Getting a Method Address

规避动态绑定的唯一方法是获取方法的地址，然后直接调用它，就像调用函数一样。当一个特定的方法将被连续多次执行，并且您希望在每次执行该方法时避免消息传递的开销时，这种方法可能是合适的。
通过在NSObject类methodForSelector:中定义的方法，您可以请求一个指向实现方法的过程的指针，然后使用该指针调用该过程。methodForSelector:返回的指针必须小心地转换为适当的函数类型。在转换中应该包括返回类型和参数类型。
下面的例子展示了实现setfill:方法的过程是如何被调用的:

```
void (*setter)(id, SEL, BOOL);
int i;
 
setter = (void (*)(id, SEL, BOOL))[target
    methodForSelector:@selector(setFilled:)];
for ( i = 0 ; i < 1000 ; i++ )
    setter(targetList[i], @selector(setFilled:), YES);
```

传递给过程的前两个参数是接收对象(self)和方法选择器(_cmd)。这些参数隐藏在方法语法中，但在作为函数调用方法时必须显式。
使用methodForSelector:绕过动态绑定可以节省消息传递所需的大部分时间。但是，只有在多次重复某个特定消息的情况下，节省才会显著，如上所示的for循环中所示。
注意，methodForSelector:由Cocoa运行时系统提供;这不是Objective-C语言本身的特性。